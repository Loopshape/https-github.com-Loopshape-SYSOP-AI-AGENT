<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Prime Ionic Universe</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.13.0/gsap.min.js"></script>
<style>
body { margin:0; overflow:hidden; background:#050505; color:#0f0; font-family:monospace; cursor: crosshair;}
canvas { display:block; }
#overlay { position:absolute; top:20px; left:20px; font-size: 1.2em; text-shadow: 0 0 5px #0f0; }
</style>
</head>
<body>
<div id="overlay">Prime Ionic Universe</div>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// --- Mouse Tracking ---
const mouse = new THREE.Vector2();
window.addEventListener('mousemove', (event) => {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
});


// --- Scene & Camera ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.position.z = 35;
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- Post-processing (Bloom) ---
const renderScene = new RenderPass(scene, camera);
const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.5, 0.1);
const composer = new EffectComposer(renderer);
composer.addPass(renderScene);
composer.addPass(bloomPass);

// --- Starfield ---
const starVertices = [];
for (let i = 0; i < 15000; i++) {
    const x = (Math.random() - 0.5) * 2000;
    const y = (Math.random() - 0.5) * 2000;
    const z = (Math.random() - 0.5) * 2000;
    starVertices.push(x, y, z);
}
const starGeometry = new THREE.BufferGeometry();
starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
const starMaterial = new THREE.PointsMaterial({ color: 0x888888, size: 0.7 });
const stars = new THREE.Points(starGeometry, starMaterial);
scene.add(stars);


// --- Prime Objects ---
const primeObjects = [];
const primeMaterial = new THREE.MeshPhysicalMaterial({
    color: 0xffd700,
    metalness: 0.9,
    roughness: 0.2,
    clearcoat: 1,
    clearcoatRoughness: 0.1,
    emissive: 0x443300
});
const icosphere = new THREE.Mesh(new THREE.IcosahedronGeometry(2, 0), primeMaterial);
icosphere.position.set(0, 0, 0);
scene.add(icosphere);
primeObjects.push(icosphere);

const torusKnot = new THREE.Mesh(new THREE.TorusKnotGeometry(4, 0.5, 100, 16), primeMaterial);
torusKnot.position.set(0, 0, 0);
torusKnot.scale.set(3,3,3);
scene.add(torusKnot);
primeObjects.push(torusKnot);


// --- Molecule Class ---
class Molecule {
    constructor(){
        this.group = new THREE.Group();
        scene.add(this.group);
        this.group.position.set((Math.random()-0.5)*40, (Math.random()-0.5)*20, (Math.random()-0.5)*20);

        // Oxygen
        this.oxygen = new THREE.Mesh(new THREE.SphereGeometry(1,32,32), new THREE.MeshPhysicalMaterial({color:0xff2222,emissive:0xff2222, emissiveIntensity:2, roughness: 0.2, metalness: 0.1}));
        this.group.add(this.oxygen);

        // Hydrogens
        this.h1 = new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32), new THREE.MeshStandardMaterial({color:0xffffff,emissive:0xdddddd, roughness: 0.5}));
        this.h1.position.set(1.5,0.8,0); this.group.add(this.h1);
        this.h2 = new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32), new THREE.MeshStandardMaterial({color:0xffffff,emissive:0xdddddd, roughness: 0.5}));
        this.h2.position.set(-1.5,0.8,0); this.group.add(this.h2);

        // Bonds
        this.bonds = [];
        this.createBond(this.oxygen,this.h1);
        this.createBond(this.oxygen,this.h2);

        // Electrons
        this.electrons = [];
        const numElectrons = 4 + Math.floor(Math.random() * 5);
        for(let i=0;i<numElectrons;i++){
            const e = new THREE.Mesh(new THREE.SphereGeometry(0.2,16,16), new THREE.MeshPhysicalMaterial({color:0x00ffff,emissive:0x00ffff, emissiveIntensity: 3, roughness: 0.1, metalness: 0.1 }));
            e.userData.radius = 3 + Math.random()*2;
            e.userData.angle = Math.random()*Math.PI*2;
            e.userData.speed = 0.01 + Math.random()*0.02;
            e.userData.isFree = false;
            this.electrons.push(e);
            scene.add(e);

            gsap.to(e.scale,{duration:0.5+Math.random(), x:0.5, y:0.5, z:0.5, yoyo:true, repeat:-1, ease:"sine.inOut"});
        }

        // Drift
        this.vx = (Math.random()-0.5)*0.03;
        this.vy = (Math.random()-0.5)*0.03;
        this.vz = (Math.random()-0.5)*0.03;
    }

    createBond(a,b){
        const geom = new THREE.BufferGeometry().setFromPoints([a.position,b.position]);
        const line = new THREE.Line(geom,new THREE.LineBasicMaterial({color:0xaaaaaa, transparent: true, opacity: 0.5}));
        this.group.add(line);
        this.bonds.push(line);
    }

    update(){
        this.group.position.x += this.vx;
        this.group.position.y += this.vy;
        this.group.position.z += this.vz;

        if(Math.abs(this.group.position.x)>40) this.vx*=-1;
        if(Math.abs(this.group.position.y)>25) this.vy*=-1;
        if(Math.abs(this.group.position.z)>25) this.vz*=-1;

        this.electrons.forEach(e=>{
            if(!e.userData.isFree){
                e.userData.angle += e.userData.speed;
                e.position.x = this.group.position.x + Math.cos(e.userData.angle)*e.userData.radius;
                e.position.z = this.group.position.z + Math.sin(e.userData.angle)*e.userData.radius;
                e.position.y = this.group.position.y + Math.sin(e.userData.angle*2)*0.5;
            } else {
                 e.position.add(e.userData.velocity);
            }
        });

        if(Math.random()<0.0005 && this.electrons.length > 0){
            const e = this.electrons[Math.floor(Math.random()*this.electrons.length)];
            if (!e.userData.isFree) {
                 e.userData.isFree = true;
                 e.userData.velocity = new THREE.Vector3().subVectors(e.position, this.group.position).normalize().multiplyScalar(0.5);
            }
        }
    }
}

// --- Molecules Array ---
const molecules = Array.from({length: 8}, () => new Molecule());

// --- Lights ---
scene.add(new THREE.AmbientLight(0xffffff,0.2));
const pointLight = new THREE.PointLight(0xffffff, 1, 100);
pointLight.position.set(10, 10, 10);
scene.add(pointLight);

// --- Animate ---
const clock = new THREE.Clock();
function animate(){
    requestAnimationFrame(animate);
    const delta = clock.getDelta();

    camera.position.x += (mouse.x * 5 - camera.position.x) * 0.05;
    camera.position.y += (-mouse.y * 5 - camera.position.y) * 0.05;
    camera.lookAt(scene.position);

    primeObjects.forEach((o, i) => {
        o.rotation.x += 0.001 + i * 0.0005;
        o.rotation.y += 0.002 + i * 0.0005;
    });

    molecules.forEach(m=>m.update());

    // Electron interactions
    for(let i=0;i<molecules.length;i++){
        for(let j=i+1;j<molecules.length;j++){
            molecules[i].electrons.forEach(e1=>{
                molecules[j].electrons.forEach(e2=>{
                    const dist2 = e1.position.distanceToSquared(e2.position);
                    if(dist2<1){
                        const force = 0.02;
                        const direction = new THREE.Vector3().subVectors(e1.position, e2.position).normalize();
                        e1.position.add(direction.clone().multiplyScalar(force));
                        e2.position.add(direction.clone().multiplyScalar(-force));
                    }
                });
            });
        }
    }

    composer.render(delta);
}

// --- Event Listeners ---
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}, false);


// --- GSAP Animation ---
gsap.to('#overlay',{duration:3, textShadow: "0 0 10px #0f0, 0 0 20px #0f0", yoyo:true, repeat:-1, ease:'power1.inOut'});

animate();
</script>
</body>
</html>