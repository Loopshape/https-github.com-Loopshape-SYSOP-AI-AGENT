<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Omega Void Recursive AI Atom Portal</title>
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#000}
canvas{display:block}
#ui-panel {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  padding: 15px;
  background: rgba(0, 10, 20, 0.7);
  border: 1px solid #00ffff;
  border-radius: 10px;
  box-shadow: 0 0 15px #00ffff, 0 0 30px #00ffff inset;
  display: flex;
  align-items: center;
  gap: 10px;
  z-index: 100;
  font-family: 'Courier New', monospace;
}
#prompt-input {
  background: transparent;
  border: none;
  border-bottom: 1px solid #00ffff;
  color: #00ffff;
  font-size: 16px;
  width: 300px;
  padding: 5px;
}
#prompt-input::placeholder {
  color: rgba(0, 255, 255, 0.5);
}
#prompt-input:focus {
  outline: none;
  box-shadow: 0 1px 0 #00ffff;
}
#submit-prompt {
  background: #00ffff;
  border: none;
  color: #000;
  padding: 8px 15px;
  cursor: pointer;
  border-radius: 5px;
  font-weight: bold;
  transition: all 0.2s ease;
  text-transform: uppercase;
}
#submit-prompt:hover:not(:disabled) {
  background: #fff;
  box-shadow: 0 0 10px #fff;
}
#submit-prompt:disabled {
  background: #555;
  color: #888;
  cursor: not-allowed;
  opacity: 0.7;
}
#loader {
  border: 4px solid rgba(0, 255, 255, 0.3);
  border-left-color: #00ffff;
  border-radius: 50%;
  width: 20px;
  height: 20px;
  animation: spin 1s linear infinite;
}
@keyframes spin {
  to { transform: rotate(360deg); }
}
.hidden {
  display: none;
}
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/",
    "@google/genai": "https://esm.sh/@google/genai"
  }
}
</script>
</head>
<body>
<div id="ui-panel">
  <input type="text" id="prompt-input" placeholder="Loading AI & Font..." disabled>
  <button id="submit-prompt" disabled>Transmit</button>
  <div id="loader" class="hidden"></div>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { GoogleGenAI } from '@google/genai';
import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';


// ----- UI & AI Setup -----
const promptInput = document.getElementById('prompt-input');
const submitButton = document.getElementById('submit-prompt');
const loader = document.getElementById('loader');
let ai;
let font;
const aiTextGroup = new THREE.Group();

try {
  ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
} catch (error) {
  console.error("Failed to initialize Gemini API. API_KEY might be missing.", error);
  promptInput.placeholder = "AI offline.";
}

const fontLoader = new FontLoader();
fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.157.0/examples/fonts/helvetiker_regular.typeface.json', (loadedFont) => {
  font = loadedFont;
  if (ai) {
      submitButton.disabled = false;
      promptInput.disabled = false;
      promptInput.placeholder = "Transmit to the Void...";
  }
});

submitButton.addEventListener('click', handlePrompt);
promptInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') handlePrompt();
});

async function handlePrompt() {
  const prompt = promptInput.value;
  if (!prompt || submitButton.disabled) return;

  promptInput.disabled = true;
  submitButton.disabled = true;
  loader.classList.remove('hidden');

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
    });
    const text = response.text;
    visualizeResponse(text);
  } catch (error) {
    console.error("Error calling Gemini API:", error);
    visualizeResponse("TRANSMISSION FAILED :: CHECK CONSOLE");
  } finally {
    promptInput.value = '';
    promptInput.disabled = false;
    submitButton.disabled = false;
    loader.classList.add('hidden');
  }
}

function visualizeResponse(text) {
  // Clear previous text
  while (aiTextGroup.children.length > 0) {
    const child = aiTextGroup.children[0];
    aiTextGroup.remove(child);
    child.geometry.dispose();
    child.material.dispose();
  }

  const words = text.split(/\s+/).filter(w => w.length > 0);
  const material = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true });

  words.forEach((word, index) => {
    const geometry = new TextGeometry(word, {
      font: font,
      size: 8,
      height: 0.5,
      curveSegments: 4,
    });
    geometry.center();

    const textMesh = new THREE.Mesh(geometry, material.clone());
    
    textMesh.userData = {
      startTime: Date.now(),
      angle: (index / words.length) * Math.PI * 6,
      radius: 80,
      life: 6000 + Math.random() * 3000
    };
    aiTextGroup.add(textMesh);
  });
}

function updateAIText() {
  const now = Date.now();
  for (let i = aiTextGroup.children.length - 1; i >= 0; i--) {
    const textMesh = aiTextGroup.children[i];
    const elapsedTime = now - textMesh.userData.startTime;
    const lifeRatio = elapsedTime / textMesh.userData.life;

    if (lifeRatio > 1) {
      aiTextGroup.remove(textMesh);
      textMesh.geometry.dispose();
      textMesh.material.dispose();
      continue;
    }
    
    const currentRadius = textMesh.userData.radius + lifeRatio * 500;
    const currentAngle = textMesh.userData.angle + lifeRatio * Math.PI * 3;

    textMesh.position.set(
      Math.cos(currentAngle) * currentRadius,
      Math.sin(lifeRatio * Math.PI * 5) * 60,
      Math.sin(currentAngle) * currentRadius
    );
    textMesh.lookAt(camera.position);
    textMesh.material.opacity = 1.0 - Math.pow(lifeRatio, 2);
  }
}

// ----- Scene Setup -----
const scene=new THREE.Scene();
scene.add(aiTextGroup);
const camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,5000);
camera.position.set(0,0,800);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

const composer=new EffectComposer(renderer);
composer.addPass(new RenderPass(scene,camera));
const bloomPass=new UnrealBloomPass(new THREE.Vector2(window.innerWidth,window.innerHeight),1.2,0.4,0.85);
composer.addPass(bloomPass);

const controls=new OrbitControls(camera,renderer.domElement);
controls.enableDamping=true;
controls.enablePan=false;

// ----- Starfield -----
const starsGeo=new THREE.BufferGeometry();
const starCount=2000;
const starPositions=new Float32Array(starCount*3);
for(let i=0;i<starCount*3;i++) starPositions[i]=(Math.random()-0.5)*5000;
starsGeo.setAttribute('position',new THREE.BufferAttribute(starPositions,3));
const starsMat=new THREE.PointsMaterial({color:0xffffff,size:1.5,transparent:true,opacity:0.8});
scene.add(new THREE.Points(starsGeo,starsMat));

// ----- Nucleus -----
const nucleusGeometry=new THREE.SphereGeometry(50,64,64);
const nucleusMaterial=new THREE.MeshPhysicalMaterial({
  color:0xB400B4, emissive:0x880088, emissiveIntensity:1.5,
  roughness:0.2, metalness:0.7, clearcoat:1.0, clearcoatRoughness:0.2
});
const nucleus=new THREE.Mesh(nucleusGeometry,nucleusMaterial);
scene.add(nucleus);

// ----- Glow Sprite -----
const glowMat=new THREE.SpriteMaterial({
  map:new THREE.TextureLoader().load('https://i.imgur.com/Oq0tI0k.png'),
  color:0xB400B4, transparent:true, blending:THREE.AdditiveBlending
});
const glow=new THREE.Sprite(glowMat);
glow.scale.set(150,150,1);
nucleus.add(glow);

// ----- Lights -----
scene.add(new THREE.AmbientLight(0x330033,0.4));
const pointLight=new THREE.PointLight(0xffffff,1.2,0);
pointLight.position.set(200,200,200);
scene.add(pointLight);

// ----- Electron / Orbit System -----
const ORBIT_COUNT=8;
const electrons=[];
const trails=[];

for(let i=0;i<ORBIT_COUNT;i++){
  const geo=new THREE.SphereGeometry(5,16,16);
  const mat=new THREE.MeshStandardMaterial({
    color:new THREE.Color(`hsl(${270+i*15},100%,70%)`),
    emissive:new THREE.Color(`hsl(${270+i*15},100%,50%)`),
    emissiveIntensity:1.2
  });
  const mesh=new THREE.Mesh(geo,mat);
  mesh.userData={radius:150+i*25,baseSpeed:0.01+Math.random()*0.02,angle:Math.random()*Math.PI*2,zAngle:Math.random()*Math.PI*2,trailPositions:[],microParticles:[]};
  electrons.push(mesh);
  scene.add(mesh);

  const trailGeo=new THREE.BufferGeometry();
  const trailMat=new THREE.PointsMaterial({color:mat.color,size:3,transparent:true,opacity:0.8});
  const positions=new Float32Array(50*3);
  const trailPoints=new THREE.Points(trailGeo,trailMat);
  trailGeo.setAttribute('position',new THREE.BufferAttribute(positions,3));
  scene.add(trailPoints);
  trails.push({mesh,points:trailPoints,positions});
}

// ----- Audio Reactive -----
const audioCtx=new (window.AudioContext||window.webkitAudioContext)();
navigator.mediaDevices.getUserMedia({audio:true}).then(stream=>{
  const src=audioCtx.createMediaStreamSource(stream);
  const analyser=audioCtx.createAnalyser();
  src.connect(analyser);
  analyser.fftSize=64;
  const dataArray=new Uint8Array(analyser.frequencyBinCount);
  function react(){
    analyser.getByteFrequencyData(dataArray);
    const avg=dataArray.reduce((a,b)=>a+b,0)/dataArray.length;
    nucleus.scale.setScalar(1+avg/300);
    glow.scale.setScalar(150*(1+avg/400));
    requestAnimationFrame(react);
  }
  react();
}).catch(e=>console.log("Audio unavailable:",e));

// ----- AI Forces / Chaos Auto-Grow -----
function aiForces(el,index){
  // 2244: orbit perturbation
  el.userData.radius += Math.sin(Date.now()*0.0005+index)*0.3;
  el.userData.speed=el.userData.baseSpeed*(1+0.3*Math.sin(Date.now()*0.001+index*2));

  // loop: emissive pulse
  const pulse=Math.sin(Date.now()*0.003+index)*0.5+0.5;
  el.material.emissiveIntensity=0.8+pulse*0.8;

  // coin: color chaos
  const hue=(270+index*15+Math.sin(Date.now()*0.001+index*5)*30)%360;
  el.material.color.setHSL(hue/360,1.0,0.7);
  el.material.emissive.setHSL(hue/360,1.0,0.5);

  // --- Chaos Auto-Grow: spawn micro-particles ---
  if(Math.random()<0.01 && el.userData.microParticles.length<12){
    const mgeo=new THREE.SphereGeometry(2,8,8);
    const mmat=new THREE.MeshStandardMaterial({color:el.material.color.clone(),emissive:el.material.emissive.clone(),emissiveIntensity:1.0});
    const m=new THREE.Mesh(mgeo,mmat);
    m.userData={radius:Math.random()*30+10,angle:Math.random()*Math.PI*2,speed:0.02+Math.random()*0.03};
    el.userData.microParticles.push(m);
    scene.add(m);
  }

  // Update micro-particles
  el.userData.microParticles.forEach(mp=>{
    mp.userData.angle+=mp.userData.speed;
    const r=el.userData.radius+mp.userData.radius;
    mp.position.set(Math.cos(mp.userData.angle)*r,Math.sin(mp.userData.angle)*r*0.3,Math.sin(mp.userData.angle)*r);
  });
}

// ----- Animate Loop -----
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  const time=Date.now()*0.001;
  nucleus.rotation.y=time*0.3;

  updateAIText();

  electrons.forEach((el,i)=>{
    aiForces(el,i);

    el.userData.angle+=el.userData.speed;
    el.userData.zAngle+=el.userData.speed*0.4;
    const r=el.userData.radius;
    el.position.set(Math.cos(el.userData.angle)*r,Math.sin(el.userData.zAngle)*20,Math.sin(el.userData.angle)*r);

    // Update trail
    el.userData.trailPositions.push(el.position.clone());
    if(el.userData.trailPositions.length>50) el.userData.trailPositions.shift();
    const posArray=trails[i].positions;
    el.userData.trailPositions.forEach((p,idx)=>{
      posArray[idx*3]=p.x; posArray[idx*3+1]=p.y; posArray[idx*3+2]=p.z;
    });
    for (let j = el.userData.trailPositions.length; j < 50; j++) {
      posArray[j*3] = posArray[(el.userData.trailPositions.length-1)*3];
      posArray[j*3+1] = posArray[(el.userData.trailPositions.length-1)*3+1];
      posArray[j*3+2] = posArray[(el.userData.trailPositions.length-1)*3+2];
    }
    trails[i].points.geometry.attributes.position.needsUpdate=true;
  });

  composer.render();
}
animate();

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
  composer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>